"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Iterable, Mapping, Sequence
from typing import Any, Literal, NamedTuple, Protocol, overload
from langchain_core.callbacks import Callbacks
from langchain_core.callbacks.manager import AsyncParentRunManager, ParentRunManager
from langchain_core.runnables.config import RunnableConfig
from langgraph.checkpoint.base import BaseCheckpointSaver, Checkpoint, PendingWrite, V
from langgraph.store.base import BaseStore
from langgraph._internal._scratchpad import PregelScratchpad
from langgraph.channels.base import BaseChannel
from langgraph.managed.base import ManagedValueMapping
from langgraph.pregel._read import INPUT_CACHE_KEY_TYPE, PregelNode
from langgraph.types import All, CachePolicy, PregelExecutableTask, PregelTask, RetryPolicy, Send

GetNextVersion = Callable[[V | None, None], V]
SUPPORTS_EXC_NOTES = ...
class WritesProtocol(Protocol):
    """Protocol for objects containing writes to be applied to checkpoint.
    Implemented by PregelTaskWrites and PregelExecutableTask."""
    @property
    def path(self) -> tuple[str | int | tuple, ...]:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def writes(self) -> Sequence[tuple[str, Any]]:
        ...
    
    @property
    def triggers(self) -> Sequence[str]:
        ...
    


class PregelTaskWrites(NamedTuple):
    """Simplest implementation of WritesProtocol, for usage with writes that
    don't originate from a runnable task, eg. graph input, update_state, etc."""
    path: tuple[str | int | tuple, ...]
    name: str
    writes: Sequence[tuple[str, Any]]
    triggers: Sequence[str]
    ...


class Call:
    __slots__ = ...
    func: Callable
    input: tuple[tuple[Any, ...], dict[str, Any]]
    retry_policy: Sequence[RetryPolicy] | None
    cache_policy: CachePolicy | None
    callbacks: Callbacks
    def __init__(self, func: Callable, input: tuple[tuple[Any, ...], dict[str, Any]], *, retry_policy: Sequence[RetryPolicy] | None, cache_policy: CachePolicy | None, callbacks: Callbacks) -> None:
        ...
    


def should_interrupt(checkpoint: Checkpoint, interrupt_nodes: All | Sequence[str], tasks: Iterable[PregelExecutableTask]) -> list[PregelExecutableTask]:
    """Check if the graph should be interrupted based on current state."""
    ...

def local_read(scratchpad: PregelScratchpad, channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, task: WritesProtocol, select: list[str] | str, fresh: bool = ...) -> dict[str, Any] | Any:
    """Function injected under CONFIG_KEY_READ in task config, to read current state.
    Used by conditional edges to read a copy of the state with reflecting the writes
    from that node only."""
    ...

def increment(current: int | None, channel: None) -> int:
    """Default channel versioning function, increments the current int version."""
    ...

def apply_writes(checkpoint: Checkpoint, channels: Mapping[str, BaseChannel], tasks: Iterable[WritesProtocol], get_next_version: GetNextVersion | None, trigger_to_nodes: Mapping[str, Sequence[str]]) -> set[str]:
    """Apply writes from a set of tasks (usually the tasks from a Pregel step)
    to the checkpoint and channels, and return managed values writes to be applied
    externally.

    Args:
        checkpoint: The checkpoint to update.
        channels: The channels to update.
        tasks: The tasks to apply writes from.
        get_next_version: Optional function to determine the next version of a channel.
        trigger_to_nodes: Mapping of channel names to the set of nodes that can be triggered by updates to that channel.

    Returns:
        Set of channels that were updated in this step.
    """
    ...

@overload
def prepare_next_tasks(checkpoint: Checkpoint, pending_writes: list[PendingWrite], processes: Mapping[str, PregelNode], channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, config: RunnableConfig, step: int, stop: int, *, for_execution: Literal[False], store: Literal[None] = ..., checkpointer: Literal[None] = ..., manager: Literal[None] = ..., trigger_to_nodes: Mapping[str, Sequence[str]] | None = ..., updated_channels: set[str] | None = ..., retry_policy: Sequence[RetryPolicy] = ..., cache_policy: Literal[None] = ...) -> dict[str, PregelTask]:
    ...

@overload
def prepare_next_tasks(checkpoint: Checkpoint, pending_writes: list[PendingWrite], processes: Mapping[str, PregelNode], channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, config: RunnableConfig, step: int, stop: int, *, for_execution: Literal[True], store: BaseStore | None, checkpointer: BaseCheckpointSaver | None, manager: None | ParentRunManager | AsyncParentRunManager, trigger_to_nodes: Mapping[str, Sequence[str]] | None = ..., updated_channels: set[str] | None = ..., retry_policy: Sequence[RetryPolicy] = ..., cache_policy: CachePolicy | None = ...) -> dict[str, PregelExecutableTask]:
    ...

def prepare_next_tasks(checkpoint: Checkpoint, pending_writes: list[PendingWrite], processes: Mapping[str, PregelNode], channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, config: RunnableConfig, step: int, stop: int, *, for_execution: bool, store: BaseStore | None = ..., checkpointer: BaseCheckpointSaver | None = ..., manager: None | ParentRunManager | AsyncParentRunManager = ..., trigger_to_nodes: Mapping[str, Sequence[str]] | None = ..., updated_channels: set[str] | None = ..., retry_policy: Sequence[RetryPolicy] = ..., cache_policy: CachePolicy | None = ...) -> dict[str, PregelTask] | dict[str, PregelExecutableTask]:
    """Prepare the set of tasks that will make up the next Pregel step.

    Args:
        checkpoint: The current checkpoint.
        pending_writes: The list of pending writes.
        processes: The mapping of process names to PregelNode instances.
        channels: The mapping of channel names to BaseChannel instances.
        managed: The mapping of managed value names to functions.
        config: The `Runnable` configuration.
        step: The current step.
        for_execution: Whether the tasks are being prepared for execution.
        store: An instance of BaseStore to make it available for usage within tasks.
        checkpointer: `Checkpointer` instance used for saving checkpoints.
        manager: The parent run manager to use for the tasks.
        trigger_to_nodes: Optional: Mapping of channel names to the set of nodes
            that are can be triggered by that channel.
        updated_channels: Optional. Set of channel names that have been updated during
            the previous step. Using in conjunction with trigger_to_nodes to speed
            up the process of determining which nodes should be triggered in the next
            step.

    Returns:
        A dictionary of tasks to be executed. The keys are the task ids and the values
        are the tasks themselves. This is the union of all PUSH tasks (Sends)
        and PULL tasks (nodes triggered by edges).
    """
    ...

PUSH_TRIGGER = ...
class _TaskIDFn(Protocol):
    def __call__(self, namespace: bytes, *parts: str | bytes) -> str:
        ...
    


def prepare_single_task(task_path: tuple[Any, ...], task_id_checksum: str | None, *, checkpoint: Checkpoint, checkpoint_id_bytes: bytes, checkpoint_null_version: V | None, pending_writes: list[PendingWrite], processes: Mapping[str, PregelNode], channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, config: RunnableConfig, step: int, stop: int, for_execution: bool, store: BaseStore | None = ..., checkpointer: BaseCheckpointSaver | None = ..., manager: None | ParentRunManager | AsyncParentRunManager = ..., input_cache: dict[INPUT_CACHE_KEY_TYPE, Any] | None = ..., cache_policy: CachePolicy | None = ..., retry_policy: Sequence[RetryPolicy] = ...) -> None | PregelTask | PregelExecutableTask:
    """Prepares a single task for the next Pregel step, given a task path, which
    uniquely identifies a PUSH or PULL task within the graph."""
    ...

def prepare_push_task_functional(task_path: tuple[str, tuple, int, str, Call], task_id_checksum: str | None, *, checkpoint: Checkpoint, checkpoint_id_bytes: bytes, pending_writes: list[PendingWrite], channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, config: RunnableConfig, step: int, stop: int, for_execution: bool, store: BaseStore | None = ..., checkpointer: BaseCheckpointSaver | None = ..., manager: None | ParentRunManager | AsyncParentRunManager = ..., cache_policy: CachePolicy | None = ..., retry_policy: Sequence[RetryPolicy] = ..., parent_ns: str, task_id_func: _TaskIDFn) -> PregelTask | PregelExecutableTask:
    """Prepare a push task with an attached caller. Used for the functional API."""
    ...

def prepare_push_task_send(task_path: tuple[str, tuple], task_id_checksum: str | None, *, checkpoint: Checkpoint, checkpoint_id_bytes: bytes, pending_writes: list[PendingWrite], channels: Mapping[str, BaseChannel], managed: ManagedValueMapping, config: RunnableConfig, step: int, stop: int, for_execution: bool, store: BaseStore | None = ..., checkpointer: BaseCheckpointSaver | None = ..., manager: None | ParentRunManager | AsyncParentRunManager = ..., cache_policy: CachePolicy | None = ..., retry_policy: Sequence[RetryPolicy] = ..., parent_ns: str, task_id_func: _TaskIDFn, processes: Mapping[str, PregelNode]) -> PregelTask | PregelExecutableTask | None:
    ...

def checkpoint_null_version(checkpoint: Checkpoint) -> V | None:
    """Get the null version for the checkpoint, if available."""
    ...

def task_path_str(tup: str | int | tuple) -> str:
    """Generate a string representation of the task path."""
    ...

LAZY_ATOMIC_COUNTER_LOCK = ...
class LazyAtomicCounter:
    __slots__ = ...
    _counter: Callable[[], int] | None
    def __init__(self) -> None:
        ...
    
    def __call__(self) -> int:
        ...
    


def sanitize_untracked_values_in_send(packet: Send, channels: Mapping[str, BaseChannel]) -> Send:
    """Pop any values belonging to UntrackedValue channels in Send.arg for safe checkpointing.

    Send is often called with state to be passed to the dest node, which may contain
    UntrackedValues at the top level. Send is not typed and arg may be a nested dict."""
    ...

