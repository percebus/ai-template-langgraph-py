"""
This type stub file was generated by pyright.
"""

import concurrent.futures
from collections.abc import Callable, Mapping, Sequence
from contextlib import AbstractAsyncContextManager, AbstractContextManager
from types import TracebackType
from typing import Any, Literal, TypeVar
from langchain_core.callbacks import AsyncParentRunManager, ParentRunManager
from langchain_core.runnables import RunnableConfig
from langgraph.cache.base import BaseCache
from langgraph.checkpoint.base import BaseCheckpointSaver, ChannelVersions, Checkpoint, CheckpointMetadata, PendingWrite
from langgraph.store.base import BaseStore
from typing_extensions import ParamSpec, Self
from langgraph.channels.base import BaseChannel
from langgraph.managed.base import ManagedValueMapping, ManagedValueSpec
from langgraph.pregel._algo import Call, GetNextVersion
from langgraph.pregel._executor import Submit
from langgraph.pregel._read import PregelNode
from langgraph.pregel.protocol import StreamProtocol
from langgraph.types import All, CachePolicy, Durability, PregelExecutableTask, RetryPolicy

V = TypeVar("V")
P = ParamSpec("P")
WritesT = Sequence[tuple[str, Any]]
def DuplexStream(*streams: StreamProtocol) -> StreamProtocol:
    ...

class PregelLoop:
    config: RunnableConfig
    store: BaseStore | None
    stream: StreamProtocol | None
    step: int
    stop: int
    input: Any | None
    cache: BaseCache[WritesT] | None
    checkpointer: BaseCheckpointSaver | None
    nodes: Mapping[str, PregelNode]
    specs: Mapping[str, BaseChannel | ManagedValueSpec]
    input_keys: str | Sequence[str]
    output_keys: str | Sequence[str]
    stream_keys: str | Sequence[str]
    skip_done_tasks: bool
    is_nested: bool
    manager: None | AsyncParentRunManager | ParentRunManager
    interrupt_after: All | Sequence[str]
    interrupt_before: All | Sequence[str]
    durability: Durability
    retry_policy: Sequence[RetryPolicy]
    cache_policy: CachePolicy | None
    checkpointer_get_next_version: GetNextVersion
    checkpointer_put_writes: Callable[[RunnableConfig, WritesT, str], Any] | None
    checkpointer_put_writes_accepts_task_path: bool
    _checkpointer_put_after_previous: (Callable[[concurrent.futures.Future | None, RunnableConfig, Checkpoint, str, ChannelVersions], Any,] | None)
    _migrate_checkpoint: Callable[[Checkpoint], None] | None
    submit: Submit
    channels: Mapping[str, BaseChannel]
    managed: ManagedValueMapping
    checkpoint: Checkpoint
    checkpoint_id_saved: str
    checkpoint_ns: tuple[str, ...]
    checkpoint_config: RunnableConfig
    checkpoint_metadata: CheckpointMetadata
    checkpoint_pending_writes: list[PendingWrite]
    checkpoint_previous_versions: dict[str, str | float | int]
    prev_checkpoint_config: RunnableConfig | None
    status: Literal["input", "pending", "done", "interrupt_before", "interrupt_after", "out_of_steps",]
    tasks: dict[str, PregelExecutableTask]
    output: None | dict[str, Any] | Any = ...
    updated_channels: set[str] | None = ...
    def __init__(self, input: Any | None, *, stream: StreamProtocol | None, config: RunnableConfig, store: BaseStore | None, cache: BaseCache | None, checkpointer: BaseCheckpointSaver | None, nodes: Mapping[str, PregelNode], specs: Mapping[str, BaseChannel | ManagedValueSpec], input_keys: str | Sequence[str], output_keys: str | Sequence[str], stream_keys: str | Sequence[str], trigger_to_nodes: Mapping[str, Sequence[str]], durability: Durability, interrupt_after: All | Sequence[str] = ..., interrupt_before: All | Sequence[str] = ..., manager: None | AsyncParentRunManager | ParentRunManager = ..., migrate_checkpoint: Callable[[Checkpoint], None] | None = ..., retry_policy: Sequence[RetryPolicy] = ..., cache_policy: CachePolicy | None = ...) -> None:
        ...
    
    def put_writes(self, task_id: str, writes: WritesT) -> None:
        """Put writes for a task, to be read by the next tick."""
        ...
    
    def accept_push(self, task: PregelExecutableTask, write_idx: int, call: Call | None = ...) -> PregelExecutableTask | None:
        """Accept a PUSH from a task, potentially returning a new task to start."""
        ...
    
    def tick(self) -> bool:
        """Execute a single iteration of the Pregel loop.

        Returns:
            True if more iterations are needed.
        """
        ...
    
    def after_tick(self) -> None:
        ...
    
    def match_cached_writes(self) -> Sequence[PregelExecutableTask]:
        ...
    
    async def amatch_cached_writes(self) -> Sequence[PregelExecutableTask]:
        ...
    
    def output_writes(self, task_id: str, writes: WritesT, *, cached: bool = ...) -> None:
        ...
    


class SyncPregelLoop(PregelLoop, AbstractContextManager):
    def __init__(self, input: Any | None, *, stream: StreamProtocol | None, config: RunnableConfig, store: BaseStore | None, cache: BaseCache | None, checkpointer: BaseCheckpointSaver | None, nodes: Mapping[str, PregelNode], specs: Mapping[str, BaseChannel | ManagedValueSpec], trigger_to_nodes: Mapping[str, Sequence[str]], durability: Durability, manager: None | AsyncParentRunManager | ParentRunManager = ..., interrupt_after: All | Sequence[str] = ..., interrupt_before: All | Sequence[str] = ..., input_keys: str | Sequence[str] = ..., output_keys: str | Sequence[str] = ..., stream_keys: str | Sequence[str] = ..., migrate_checkpoint: Callable[[Checkpoint], None] | None = ..., retry_policy: Sequence[RetryPolicy] = ..., cache_policy: CachePolicy | None = ...) -> None:
        ...
    
    def match_cached_writes(self) -> Sequence[PregelExecutableTask]:
        ...
    
    def accept_push(self, task: PregelExecutableTask, write_idx: int, call: Call | None = ...) -> PregelExecutableTask | None:
        ...
    
    def put_writes(self, task_id: str, writes: WritesT) -> None:
        """Put writes for a task, to be read by the next tick."""
        ...
    
    def __enter__(self) -> Self:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        ...
    


class AsyncPregelLoop(PregelLoop, AbstractAsyncContextManager):
    def __init__(self, input: Any | None, *, stream: StreamProtocol | None, config: RunnableConfig, store: BaseStore | None, cache: BaseCache | None, checkpointer: BaseCheckpointSaver | None, nodes: Mapping[str, PregelNode], specs: Mapping[str, BaseChannel | ManagedValueSpec], trigger_to_nodes: Mapping[str, Sequence[str]], durability: Durability, interrupt_after: All | Sequence[str] = ..., interrupt_before: All | Sequence[str] = ..., manager: None | AsyncParentRunManager | ParentRunManager = ..., input_keys: str | Sequence[str] = ..., output_keys: str | Sequence[str] = ..., stream_keys: str | Sequence[str] = ..., migrate_checkpoint: Callable[[Checkpoint], None] | None = ..., retry_policy: Sequence[RetryPolicy] = ..., cache_policy: CachePolicy | None = ...) -> None:
        ...
    
    async def amatch_cached_writes(self) -> Sequence[PregelExecutableTask]:
        ...
    
    async def aaccept_push(self, task: PregelExecutableTask, write_idx: int, call: Call | None = ...) -> PregelExecutableTask | None:
        ...
    
    def put_writes(self, task_id: str, writes: WritesT) -> None:
        """Put writes for a task, to be read by the next tick."""
        ...
    
    async def __aenter__(self) -> Self:
        ...
    
    async def __aexit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        ...
    


