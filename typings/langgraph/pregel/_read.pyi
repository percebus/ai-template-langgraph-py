"""
This type stub file was generated by pyright.
"""

from collections.abc import AsyncIterator, Callable, Iterator, Mapping, Sequence
from functools import cached_property
from typing import Any
from langchain_core.runnables import Runnable, RunnableConfig
from langgraph._internal._runnable import RunnableCallable
from langgraph.pregel.protocol import PregelProtocol
from langgraph.types import CachePolicy, RetryPolicy

READ_TYPE = Callable[[str | Sequence[str], bool], Any | dict[str, Any]]
INPUT_CACHE_KEY_TYPE = tuple[Callable[..., Any], tuple[str, ...]]
class ChannelRead(RunnableCallable):
    """Implements the logic for reading state from CONFIG_KEY_READ.
    Usable both as a runnable as well as a static method to call imperatively."""
    channel: str | list[str]
    fresh: bool = ...
    mapper: Callable[[Any], Any] | None = ...
    def __init__(self, channel: str | list[str], *, fresh: bool = ..., mapper: Callable[[Any], Any] | None = ..., tags: list[str] | None = ...) -> None:
        ...
    
    def get_name(self, suffix: str | None = ..., *, name: str | None = ...) -> str:
        ...
    
    @staticmethod
    def do_read(config: RunnableConfig, *, select: str | list[str], fresh: bool = ..., mapper: Callable[[Any], Any] | None = ...) -> Any:
        ...
    


DEFAULT_BOUND = ...
class PregelNode:
    """A node in a Pregel graph. This won't be invoked as a runnable by the graph
    itself, but instead acts as a container for the components necessary to make
    a PregelExecutableTask for a node."""
    channels: str | list[str]
    triggers: list[str]
    mapper: Callable[[Any], Any] | None
    writers: list[Runnable]
    bound: Runnable[Any, Any]
    retry_policy: Sequence[RetryPolicy] | None
    cache_policy: CachePolicy | None
    tags: Sequence[str] | None
    metadata: Mapping[str, Any] | None
    subgraphs: Sequence[PregelProtocol]
    def __init__(self, *, channels: str | list[str], triggers: Sequence[str], mapper: Callable[[Any], Any] | None = ..., writers: list[Runnable] | None = ..., tags: list[str] | None = ..., metadata: Mapping[str, Any] | None = ..., bound: Runnable[Any, Any] | None = ..., retry_policy: RetryPolicy | Sequence[RetryPolicy] | None = ..., cache_policy: CachePolicy | None = ..., subgraphs: Sequence[PregelProtocol] | None = ...) -> None:
        ...
    
    def copy(self, update: dict[str, Any]) -> PregelNode:
        ...
    
    @cached_property
    def flat_writers(self) -> list[Runnable]:
        """Get writers with optimizations applied. Dedupes consecutive ChannelWrites."""
        ...
    
    @cached_property
    def node(self) -> Runnable[Any, Any] | None:
        """Get a runnable that combines `bound` and `writers`."""
        ...
    
    @cached_property
    def input_cache_key(self) -> INPUT_CACHE_KEY_TYPE:
        """Get a cache key for the input to the node.
        This is used to avoid calculating the same input multiple times."""
        ...
    
    def invoke(self, input: Any, config: RunnableConfig | None = ..., **kwargs: Any | None) -> Any:
        ...
    
    async def ainvoke(self, input: Any, config: RunnableConfig | None = ..., **kwargs: Any | None) -> Any:
        ...
    
    def stream(self, input: Any, config: RunnableConfig | None = ..., **kwargs: Any | None) -> Iterator[Any]:
        ...
    
    async def astream(self, input: Any, config: RunnableConfig | None = ..., **kwargs: Any | None) -> AsyncIterator[Any]:
        ...
    


